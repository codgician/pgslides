<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="尚未完成">
  <title>浅谈置换群</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="https://revealjs.com/css/reset.css">
  <link rel="stylesheet" href="https://revealjs.com/css/reveal.css">
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="https://revealjs.com/css/theme/black.css" id="theme">
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? 'https://revealjs.com/css/print/pdf.css' : 'https://revealjs.com/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="https://revealjs.com/lib/js/html5shiv.js"></script>
  <![endif]-->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
   var mathElements = document.getElementsByClassName("math");
   for (var i = 0; i < mathElements.length; i++) {
    var texText = mathElements[i].firstChild;
    if (mathElements[i].tagName == "SPAN") {
     katex.render(texText.data, mathElements[i], {
      displayMode: mathElements[i].classList.contains('display'),
      throwOnError: false,
      fleqn: false
     });
  }}});
  </script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" />
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">浅谈置换群</h1>
  <p class="author">尚未完成</p>
  <p class="date">2020.03</p>
</section>

<section>
<section id="群-g-cdot" class="title-slide slide level1">
<h1>群 <span class="math inline">(G, \cdot)</span></h1>
<p><span class="math inline">G</span> 是非空集合，且二元运算满足：</p>
<ul>
<li>结合律：<span class="math inline">(a \cdot b) \cdot c = a \cdot (b \cdot c)</span></li>
<li>单位元 <span class="math inline">e</span>：<span class="math inline">\forall a \in G, \ ea = ae = a</span></li>
<li>存在逆元：<span class="math inline">\forall a \in G, \ \exist b \in G \text{ s.t. } ab = ba = e</span></li>
</ul>
<div class="fragment">
<p>若满足交换律，则为<strong>交换群</strong></p>
</div>
<aside class="notes">
<p>对于群中的运算，我们后面会较多地称其为乘法。</p>
</aside>
</section>
<section id="子群" class="slide level2">
<h2>子群</h2>
<p>设 <span class="math inline">(G, \cdot)</span> 为群，<span class="math inline">A</span> 是 <span class="math inline">G</span> 的子集，若 <span class="math inline">(A, \cdot)</span> 成群，则称 <span class="math inline">A</span> 为 <span class="math inline">G</span> 的子群，记作 <span class="math inline">A \le G</span>；</p>
</section></section>
<section>
<section id="置换" class="title-slide slide level1">
<h1>置换</h1>
<p>一个集合的置换即从该集合映射至自身的<strong>双射</strong>。</p>
<p><span class="math display">
\sigma = 
\left(\begin{array}{c}
1 &amp; 2 &amp; \dots &amp; n \\
\sigma(1) &amp; \sigma(2) &amp; \dots &amp; \sigma(n)
\end{array}\right)
</span></p>
<p>复合运算: <span class="math inline">(f \circ g)(x) = f(g(x))</span></p>
</section>
<section id="轮换表示法" class="slide level2">
<h2>轮换表示法</h2>
<p><span class="math display"> 
\left(\begin{array}{c}
a_1 &amp; a_2 &amp; \dots &amp; a_n \\
a_2 &amp; a_3 &amp; \dots &amp; a_1
\end{array}\right) \xRightarrow{\text{记作}} (a_1 \enspace a_2 \enspace \dots \enspace a_n)
</span></p>
</section>
<section id="例" class="slide level2">
<h2>例</h2>
<p><span class="math display">
\left(\begin{array}{c} 
1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 \\ 
3 &amp; 1 &amp; 2 &amp; 5 &amp; 4 &amp; 6 
\end{array}\right) = (1 \enspace 3 \enspace 2) \cdot (4 \enspace 5) \cdot (6)
</span></p>
</section>
<section id="性质" class="slide level2">
<h2>性质</h2>
<ul>
<li>任 <span class="math inline">n</span> 元置换可表示为若不相交的轮换乘积</li>
<li>若不计次序，这些轮换是<strong>唯一决定</strong>的</li>
</ul>
<aside class="notes">
<p>不相交指子集上不相交，即不包含相同元素</p>
</aside>
</section>
<section class="slide level2">

<p><span class="math display">
\begin{aligned}
\sigma &amp; = 
\left(\begin{array}{c}
a_1 &amp; a_2 &amp; \dots &amp; a_{j - 1} &amp; a_j &amp; \dots \\
a_2 &amp; a_3 &amp; \dots &amp; a_j &amp; a_1 &amp; \dots
\end{array}\right) \\
&amp; = (a_1 \enspace a_2 \enspace \dots \enspace a_j) \cdot 
\left(\begin{array}{c}
 \dots \\
 \dots
\end{array}\right) = \dots
\end{aligned}
</span></p>
<p>递归进行下去，可得到：</p>
<p><span class="math display">
\sigma = (a_1 \enspace \dots \enspace a_j) \cdot (a_{j + 1} \enspace \dots \enspace a_e) \cdots (a_r \enspace \dots \enspace a_n)
</span></p>
</section>
<section class="slide level2">

<p>借助反证法证明其唯一性，若它还可被表示成：</p>
<p><span class="math display">
\sigma = (b_1 \enspace \dots \enspace b_i) \cdot (b_{i + 1} \enspace \dots \enspace b_t) \cdots (b_s \enspace \dots \enspace b_n)
</span></p>
<p>若存在两个轮换交集不为空，那么较大者一定还可以被进一步分解。</p>
</section>
<section id="轮换的幂运算" class="slide level2">
<h2>轮换的幂运算</h2>
<p><span class="math display">
(1 \enspace 2 \enspace 3 \enspace 4 \enspace 5 \enspace 6)
</span></p>
</section>
<section class="slide level2">

<p><span class="math display">
\begin{aligned}
&amp; (1 \enspace 2 \enspace 3 \enspace 4 \enspace 5 \enspace 6)^2 \\
&amp; = (1 \enspace 3 \enspace 5) \cdot (2 \enspace 4 \enspace 6)
\end{aligned}
</span></p>
</section>
<section class="slide level2">

<p><span class="math display">
\begin{aligned}
&amp; (1 \enspace 2 \enspace 3 \enspace 4 \enspace 5 \enspace 6)^3 \\
&amp; =  (1 \enspace 4) \cdot (2 \enspace 5) \cdot (3 \enspace 6)
\end{aligned}
</span></p>
</section>
<section class="slide level2">

<p><span class="math display">
\begin{aligned}
&amp; (1 \enspace 2 \enspace 3 \enspace 4 \enspace 5 \enspace 6)^4 \\
&amp; = (1 \enspace 5 \enspace 3) \cdot (2 \enspace 6 \enspace 4)
\end{aligned}
</span></p>
</section>
<section class="slide level2">

<h3 id="性质-1">性质</h3>
<p>若置换 <span class="math inline">T</span> 可表示为 <span class="math inline">1</span> 个长度为 <span class="math inline">n</span> 的轮换 <span class="math inline">c</span>，可用如下算法求出 <span class="math inline">T^e</span> 轮换乘积形式：</p>
<ul>
<li><span class="math inline">T^e</span> 可表示为 <span class="math inline">\gcd(n, e)</span> 个长度为 <span class="math inline">\frac{n}{\gcd(n, e)}</span> 的轮换 <span class="math inline">c&#39;</span>；</li>
<li>对于第 <span class="math inline">i</span> 个轮换 <span class="math inline">c&#39;_i</span>：<span class="math inline">c&#39;_i[j] = c[(i + ej) \bmod n]</span>。</li>
</ul>
</section></section>
<section id="置换群" class="title-slide slide level1">
<h1>置换群</h1>
<p><span class="math inline">n</span> 个元的所有置换，在复合运算 <span class="math inline">\circ</span> 下成群，称作 <span class="math inline">n</span> 元对称群 <span class="math inline">S_n</span></p>
<ul>
<li>结合律：<span class="math inline">(f \circ g) \circ h = f \circ (g \circ h)</span></li>
<li>单位元：恒等置换 <span class="math inline">e</span></li>
<li>逆元显然存在</li>
</ul>
</section>

<section>
<section id="群在集合上的作用" class="title-slide slide level1">
<h1>群在集合上的作用</h1>
<p>设 <span class="math inline">G</span> 是一个群，<span class="math inline">M</span> 是一个集合。若 <span class="math inline">G</span> 中每个元 <span class="math inline">\sigma</span> 都对应于 <span class="math inline">M</span> 的一个变换，对 <span class="math inline">\forall a \in M</span> 记变换结果为 <span class="math inline">\sigma \circ m</span>，且满足：</p>
<ul>
<li><span class="math inline">\exist e \text{ s.t. } \forall m \in M, \ e \circ m = m</span>；</li>
<li><span class="math inline">\forall \tau, \sigma \in G, \ (\tau\sigma) \circ m = \tau \circ (\sigma \circ m)</span></li>
</ul>
<p>则称 <span class="math inline">G</span> 在 <span class="math inline">M</span> 上有<strong>群作用</strong>。</p>
</section>
<section id="轨道不动元" class="slide level2">
<h2>轨道，不动元</h2>
<p>待补充……</p>
</section></section>
<section>
<section id="burnside-定理" class="title-slide slide level1">
<h1>Burnside 定理</h1>
<p>设有限群 <span class="math inline">G</span> 作用于有限集 <span class="math inline">X</span> 上，则轨道数：</p>
<p><span class="math display">
|X/G| = \frac{1}{|G|} \sum\limits_{g \in G} |X^{g}|
</span></p>
<p>其中 <span class="math inline">X^{g}</span> 代表 <span class="math inline">g</span> 的不动元构成的集合：</p>
<p><span class="math display">
X^{g} = \{ x \in X \mid g \circ x = x \}
</span></p>
</section>
<section id="例子" class="slide level2">
<h2>例子</h2>
<p>对正六边形的 <span class="math inline">6</span> 个顶点，一半涂黑色一半涂白色。若经过旋转可相互得到的方案算同一种方案，求染色方案数？</p>
</section>
<section class="slide level2">

<h3 id="分析">分析</h3>
<p><span class="math display">
M = \text{所有涂色方案， 共：} \binom{6}{3} = 20 \text{ 种}
</span></p>
<p><span class="math display">
G = \{ 0^\circ, 60^\circ, 120^\circ, 180^\circ, 240^\circ, 300^\circ \} \\
\text{（绕中心顺时针旋转）}
</span></p>
<p>记 <span class="math inline">6</span> 个顶点分别为 <span class="math inline">A_1, A_2, \dots, A_6</span>。</p>
</section>
<section class="slide level2">

<h3 id="旋转-0circ">旋转 <span class="math inline">0^\circ</span></h3>
<p><span class="math display">
\left(\begin{array}{c} 
A_1 &amp; A_2 &amp; A_3 &amp; A_4 &amp; A_5 &amp; A_6 \\ 
A_1 &amp; A_2 &amp; A_3 &amp; A_4 &amp; A_5 &amp; A_6 
\end{array}\right)
</span></p>
<p>将这一置换作用于 <span class="math inline">M</span> 中的任意元素都不会使该元素发生变化，故不动元有 <span class="math inline">20</span> 个。</p>
</section>
<section class="slide level2">

<h3 id="旋转-60circ">旋转 <span class="math inline">60^\circ</span></h3>
<p><span class="math display">
\left(\begin{array}{c} 
A_1 &amp; A_2 &amp; A_3 &amp; A_4 &amp; A_5 &amp; A_6 \\ 
A_6 &amp; A_1 &amp; A_2 &amp; A_3 &amp; A_4 &amp; A_5 
\end{array}\right)
</span></p>
<p>若要成为不动元，则应当满足：</p>
<p><span class="math display">
A_1 = A_2 = \dots = A_6
</span></p>
<p>故没有不动元</p>
</section>
<section class="slide level2">

<h3 id="旋转-120circ">旋转 <span class="math inline">120^\circ</span></h3>
<p><span class="math display">
\left(\begin{array}{c} 
A_1 &amp; A_2 &amp; A_3 &amp; A_4 &amp; A_5 &amp; A_6 \\ 
A_5 &amp; A_6 &amp; A_1 &amp; A_2 &amp; A_3 &amp; A_4 
\end{array}\right)
</span></p>
<p>若要成为不动元，则应当满足：</p>
<p><span class="math display">
A_1 = A_3 = A_5, \ A_2 = A_4 = A_6
</span></p>
<p>故不动元数量为 <span class="math inline">2</span></p>
</section>
<section class="slide level2">

<h3 id="旋转-180circ">旋转 <span class="math inline">180^\circ</span></h3>
<p><span class="math display">
\left(\begin{array}{c} 
A_1 &amp; A_2 &amp; A_3 &amp; A_4 &amp; A_5 &amp; A_6 \\ 
A_4 &amp; A_5 &amp; A_6 &amp; A_1 &amp; A_2 &amp; A_3 
\end{array}\right)
</span></p>
<p>若要成为不动元，则应当满足：</p>
<p><span class="math display">
A_1 = A_4, \ A_2 = A_5, \ A_3 = A_6
</span></p>
<p>故没有不动元</p>
</section>
<section class="slide level2">

<p>由于顺时针和逆时针旋转是等价的，因此：</p>
<ul>
<li>旋转 <span class="math inline">60^\circ</span> 与 旋转 <span class="math inline">300^\circ</span> 情形相似；</li>
<li>旋转 <span class="math inline">120^\circ</span> 与 旋转 <span class="math inline">240^\circ</span> 情形相似。</li>
</ul>
<p>轨道数：<span class="math inline">\frac{1}{6}(20 + 2 + 2) = 4</span></p>
</section></section>
<section>
<section id="pólya-计数法" class="title-slide slide level1">
<h1>Pólya 计数法</h1>
<ul>
<li>将置换表示为若干轮换乘积，若轮换内元素颜色均相同即为不动点……</li>
<li>记颜色数量为 <span class="math inline">m</span>，<span class="math inline">c(g)</span> 为置换 <span class="math inline">g</span> 被分解为不交轮换乘积的个数：</li>
</ul>
<p><span class="math display">
|X^{g}| = m^{c(g)}, \ |X/G| = \frac{1}{|G|} \sum\limits_{g \in G} m^{c(g)}
</span></p>
</section>
<section id="项链染色" class="slide level2">
<h2>项链染色</h2>
<p>长为 <span class="math inline">n</span> 的环，<span class="math inline">m</span> 种颜色对环上元素染色，经旋转或翻转都算作相同方案</p>
<p><span class="math inline">n, m \le 10^9</span></p>
</section>
<section class="slide level2">

<h3 id="旋转">旋转</h3>
<p><span class="math display">
G = \{ \frac{2\pi}{n}, \dots, (n - 1)\frac{2\pi}{n}, 2\pi \}
</span></p>
<p>旋转 <span class="math inline">i \cdot \frac{2\pi}{n}</span> 时，可拆成 <span class="math inline">\gcd(n, i)</span> 个轮换，故：</p>
<p><span class="math display">
\sum\limits_{g \in G} |X^g| = \sum\limits_{i = 1}^{n} m^{\gcd(n, i)}
</span></p>
</section>
<section class="slide level2">

<p><span class="math display">
\begin{aligned}
\sum\limits_{g \in G} |X^g| 
&amp; = \sum\limits_{i = 1}^{n} m^{\gcd(n, i)} \\
&amp; = \sum\limits_{d \mid n} m^d \sum\limits_{i = 1}^{n} [ \gcd(n, i) = d ] \\
&amp; =\sum\limits_{d \mid n} m^d \sum\limits_{i = 1}^{n} [ \gcd(\frac{n}{d}, i) = 1 ] \\
&amp; = \sum\limits_{d \mid n} m^d \cdot \varphi(\frac{n}{d})
\end{aligned}
</span></p>
<p>复杂度变成了 <span class="math inline">\mathcal{O}(\sqrt{N})</span></p>
</section>
<section class="slide level2">

<h3 id="翻转">翻转</h3>
<ul>
<li><span class="math inline">n</span> 为偶数：
<ul>
<li><span class="math inline">\frac{1}{2}n</span> 条过点的对称轴：<span class="math inline">c(g) = \frac{1}{2}n + 1</span></li>
<li><span class="math inline">\frac{1}{2}n</span> 条过边的对称轴：<span class="math inline">c(g) = \frac{1}{2}n</span></li>
</ul></li>
<li><span class="math inline">n</span> 为奇数：
<ul>
<li><span class="math inline">n</span> 条 既过点又过边的对称轴：<span class="math inline">c(g) = \frac{1}{2}(n - 1) + 1</span></li>
</ul></li>
</ul>
<p><span class="math display">
|G&#39;| = n
</span></p>
</section>
<section class="slide level2">

<p><span class="math display">
|X/G| = \frac{1}{|G| + |G&#39;|} (\sum\limits_{g \in G} |X^g| + \sum\limits_{g&#39; \in G&#39;} |X^{g&#39;}|)
</span></p>
</section>
<section id="完全图同构计数" class="slide level2">
<h2>完全图同构计数</h2>
<p><span class="math inline">n</span> 个点无向完全图，<span class="math inline">m</span> 种颜色给边染色，求互不同构无向完全图个数。</p>
<p><span class="math inline">n \le 60, \ m \le 10^3</span></p>
<div class="fragment">
<ul>
<li>两张图若<strong>对点重标号</strong>后可以重合即为同构；</li>
<li>把边的不存在当作一种颜色可将其推广至一般无向图同构。</li>
</ul>
</div>
</section>
<section class="slide level2">

<ul>
<li>对点的置换群即 <span class="math inline">n</span> 阶对称群 <span class="math inline">S_n</span>，<span class="math inline">|S_n| = n!</span></li>
<li>每个点置换可以被表示成若干点轮换的乘积，而该点置换下，边两端的两点有两种情况：
<ul>
<li>在同一个轮换里；</li>
<li>在两个不同轮换里。</li>
</ul></li>
</ul>
<aside class="notes">
<p>注意接下来考虑的是轮换，那么对应的操作就是循环右移</p>
</aside>
</section>
<section class="slide level2">

<ul>
<li><p>两点在同一轮换里的边：记点轮换大小为 <span class="math inline">x</span>，则可构成 <span class="math inline">\left\lfloor \frac{x}{2} \right\rfloor</span> 个边轮换。</p>
<p>考虑 <span class="math inline">x</span> 个点构成的完全图，将点等距离放在圆周上，则显然长度相等的线段构成一个边轮换，共 <span class="math inline">\left\lfloor \frac{x}{2} \right\rfloor</span> 个。</p></li>
</ul>
</section>
<section class="slide level2">

<ul>
<li><p>两点在不同轮换里的边：记点轮换大小分别为 <span class="math inline">x, y</span>，则可构成 <span class="math inline">\gcd(x, y)</span> 个边轮换。</p>
<p>需要移 <span class="math inline">\text{lcm}(x, y)</span> 次才能转回原图形，发现每个轮换大小均为 <span class="math inline">\text{lcm}(x, y)</span>。共 <span class="math inline">xy</span> 条边，则轮换个数 <span class="math inline">\frac{xy}{\text{lcm}(x, y)} = \gcd(x, y)</span> 个。</p></li>
</ul>
</section>
<section class="slide level2">

<ul>
<li>对 <span class="math inline">n</span> 的每一种拆分方案：<span class="math inline">n = \sum\limits_{i = 1}^{k} t_i a_i</span>，其中 <span class="math inline">a_i</span> 代表点轮换大小，<span class="math inline">t_i</span> 为该大小的点轮换个数。则满足上述条件的点置换个数为： <span class="math display">
\frac{n!}{\prod\limits_{i = 1}^{k} t_i! \cdot a_i^{t_i}}
</span></li>
</ul>
</section>
<section class="slide level2">

<ul>
<li>其中除去 <span class="math inline">a_i^{t_i}</span> 的原因是因为每个大小为 <span class="math inline">a_i</span> 的点轮换会被重复算 <span class="math inline">a_i</span> 次。</li>
<li>爆搜所有的拆分方案即可，同一边轮换内的边都应当同色，运用一下 Pólya 定理即可。</li>
</ul>
</section></section>
<section>
<section id="南昌-j.-summon" class="title-slide slide level1">
<h1>南昌 J. Summon</h1>
<p>现要从 <span class="math inline">4</span> 种不同的水晶中取 <span class="math inline">n</span> 个围成一个圈，但有 <span class="math inline">m</span> 个限制条件：每条限制条件要求某四种水晶不能在围成的圈中连续出现。通过旋转可互相得到的方案算作一种方案，问有多少种本质不同的方案？（结果模 <span class="math inline">998244353</span>）</p>
<p><span class="math inline">n \le 10^5, m \le 256</span></p>
</section>
<section id="分析-1" class="slide level2">
<h2>分析</h2>
<ul>
<li>由于带上了限制条件，无法直接通过 Pólya 计数法得到结果；</li>
<li>若有 <span class="math inline">m</span> 个轮换，则只需要确定前 <span class="math inline">m</span> 个水晶的颜色即可！</li>
</ul>
</section>
<section class="slide level2">

<ul>
<li>记 <span class="math inline">a\langle i, j, k, l \rangle</span> 代表是否允许 <span class="math inline">i, j, k, l</span> 四种颜色相邻；</li>
<li>记 <span class="math inline">dp\langle i, j, k, l \rangle</span> 代表 <span class="math inline">i</span> 个水晶排成一排，最后三个元素的颜色分别为 <span class="math inline">j, k, l</span>，则方案数： <span class="math display">
dp\langle i, j, k, l \rangle = \sum\limits_{s} dp \langle i - 1, s, j, k \rangle \cdot a \langle s, j, k, l \rangle
</span></li>
<li>枚举前三个水晶的颜色 <span class="math inline">\langle j, k, l \rangle</span>，则 <span class="math inline">dp \langle i + 3, j, k, l \rangle</span> 代表围成一圈时满足题目条件的不动点个数。</li>
</ul>
</section>
<section class="slide level2">

<p><span class="math display">
  dp\langle i, j, k, l \rangle = \sum\limits_{s} dp \langle i - 1, s, j, k \rangle \cdot a \langle s, j, k, l \rangle
</span></p>
<p><span class="math display">
\begin{aligned}
  \begin{bmatrix}
    dp \langle i, 1, 1, 1 \rangle \\
    dp \langle i, 1, 1, 2 \rangle \\
    \vdots \\
    dp \langle i, 4, 4, 4 \rangle
  \end{bmatrix}
\end{aligned}
=
\begin{aligned}
  \begin{bmatrix}
    dp \langle i - 1, 1, 1, 1 \rangle \\
    dp \langle i - 1, 1, 1, 2 \rangle \\
    \vdots \\
    dp \langle i - 1, 4, 4, 4 \rangle
  \end{bmatrix}
\end{aligned}
\cdot T
</span></p>
<p><span class="math display">
T[\langle s, j, k \rangle][\langle j, k, l \rangle] = a \langle s, j, k, l \rangle
</span></p>
</section>
<section class="slide level2">

<ul>
<li>旋转 <span class="math inline">i \cdot \frac{2\pi}{n}</span> 下不动点个数： <span class="math display">
\sum\limits_{\langle a, b, c \rangle} dp \langle \gcd(n, i) + 3, a, b, c \rangle
</span></li>
<li>接下来记之为 <span class="math inline">f(\gcd(n, i))</span></li>
<li>做一次矩阵快速幂即可得解，复杂度：<span class="math inline">\mathcal{O}(64^2\log{n})</span></li>
</ul>
</section>
<section class="slide level2">

<ul>
<li>不动点个数： <span class="math display">
\begin{aligned}
\sum\limits_{i = 1}^{n} f(\gcd(n, i)) 
&amp; = \sum\limits_{d \mid n} f(d) \cdot \sum\limits_{i = 1}^{n} [\gcd(n, i) = d] \\
&amp; = \sum\limits_{d \mid n} f(d) \cdot \varphi(\frac{n}{d})
\end{aligned}
</span></li>
<li>复杂度就变成了 <span class="math inline">\mathcal{O}(\sqrt{n} \cdot 64^2\log{n})</span></li>
</ul>
</section></section>
<section>
<section id="银川-m.-crazy-cake" class="title-slide slide level1">
<h1>银川 M. Crazy Cake</h1>
<p>圆周上均匀分布 <span class="math inline">n</span> 个点，现可连接若干点对，但要求连出的线段不可在圆内部相交（但可以在圆上相交）。经过旋转可相互得到的方案算作相同方案，有多少种本质不同方案数？（<span class="math inline">T</span> 次询问，结果模 <span class="math inline">10^9 + 7</span>）</p>
<p><span class="math display">
T \le 10^5, 2 \le n \le 10^6
</span></p>
</section>
<section id="分析-2" class="slide level2">
<h2>分析</h2>
<ul>
<li>置换群？顺时针旋转 <span class="math inline">\frac{2\pi}{n}, 2 \times \frac{2\pi}{n}, \dots, 2\pi</span>；</li>
<li>集合？所有<strong>内部不相交</strong>的方案；</li>
<li>每一种置换可表示为 <span class="math inline">\frac{n}{d}</span> 个长为 <span class="math inline">d</span> 的轮换。</li>
</ul>
</section>
<section class="slide level2">

<p><span class="math inline">d = n</span> 时的情形（即旋转 <span class="math inline">2\pi</span>）：</p>
<ul>
<li>等价于询问不考虑同构时的方案数……</li>
<li>圆周上的 <span class="math inline">n</span> 条线段不会导致相交，故先只考虑圆内部的连边……</li>
<li>记 <span class="math inline">f(n)</span> 代表 <span class="math inline">n</span> 个点只考虑<strong>内部</strong>连边的方案数，则旋转 <span class="math inline">2\pi</span> 时不动点个数为：</li>
</ul>
<p><span class="math display">
2^n \cdot f(n)
</span></p>
</section>
<section class="slide level2">

<p>首先考虑 <span class="math inline">0</span> 号点没有连边的情况：</p>
<ul>
<li>把 <span class="math inline">0</span> 号点删掉不影响答案；</li>
<li>考虑如何从 <span class="math inline">f(n - 1)</span> 转移？</li>
</ul>
</section>
<section class="slide level2">

<p><img data-src="./assets/yinchuan-m-01.png" class="plain" /></p>
<p><span class="math display">
2 \cdot f(n - 1)
</span></p>
<aside class="notes">
<p>在考虑 f(n - 1) 时，n - 2 和 n 是相邻点故我们没有考虑它们间的相邻情况；而当考虑 f(n) 是，n - 2 和 n 不是相邻点了，而这两个点是否相连都不会影响答案，所以此时方案数是 2 * f(n - 1)。</p>
</aside>
</section>
<section class="slide level2">

<p>其次考虑 <span class="math inline">0</span> 号点有连边的情况：</p>
<ul>
<li>记 <span class="math inline">0</span> 号点连出的<strong>最小标号</strong>为 <span class="math inline">i \in [1, n - 1]</span>；</li>
<li>上面这条线将图形分成了 <span class="math inline">2</span> 个部分</li>
</ul>
</section>
<section class="slide level2">

<p><img data-src="./assets/yinchuan-m-02.png" class="plain" /></p>
<p><span class="math display">
2 \cdot f(i) \cdot f(n - i + 1) \quad (i \ge 3)
</span></p>
<aside class="notes">
<p>别忘了 i = 0, 1, n - 1 是不用考虑的……</p>
<p>不清楚的话自己想想为什么 :P</p>
<p>（定义 f 的时候就把相邻点连边排除在外了）</p>
</aside>
</section>
<section class="slide level2">

<p>综上所述</p>
<p><span class="math display">
\begin{aligned}
f(n) &amp; = 2f(n - 1) \\
&amp; + f(n - 1) + 2\sum\limits_{i = 3}^{n - 2} f(i) \cdot f(n - i + 1)
\end{aligned}
</span></p>
</section>
<section class="slide level2">

<p><span class="math inline">d \neq n</span> 的情形</p>
<ul>
<li>先对每个轮换单独考虑；</li>
<li>轮换内部相邻两个点连线不会导致相交，故还是先考虑内部连边；</li>
<li></li>
</ul>
</section></section>
<section id="谢谢大家" class="title-slide slide level1">
<h1>谢谢大家</h1>

</section>
    </div>
  </div>

  <script src="https://revealjs.com/js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Push each slide change to the browser history
        history: true,
        // Transition style
        transition: 'fade', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'https://revealjs.com/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'https://revealjs.com/plugin/zoom-js/zoom.js', async: true },
          { src: 'https://revealjs.com/plugin/notes/notes.js', async: true }
        ]
      });
    </script>
    </body>
</html>
